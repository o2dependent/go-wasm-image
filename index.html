<!DOCTYPE html>
<html>

<head>
	<title>Image (Go + WASM)</title>
	<style>
		#dropZone {
			width: 400px;
			height: 200px;
			border: 2px dashed #ccc;
			border-radius: 10px;
			text-align: center;
			line-height: 200px;
			margin: 20px;
		}

		#dropZone.dragover {
			border-color: #666;
			background-color: #eee;
		}

		#previewCanvas {
			border: 1px solid #ccc;
			margin: 20px;
		}
	</style>
	<script
		src="https://cdn.tailwindcss.com"></script>

</head>

<body class="p-4">

	<input type="file" id="fileInput"
		accept="image/*">
	<div id="dropZone">Drag and drop image here
	</div>
	<div id="colorRangeList"
		class="flex flex-wrap gap-2">
	</div>
	<div id="sort-pixel-thresh-container"
		class="flex flex-col gap-2">
		<p>Sort pixel threshold</p>
		<div class="flex gap-2">
			<p class="display w-10">75</p>
			<input type="range" name="sort-pixel-thresh"
				max="255" min="0" value="75" step="1">
		</div>
	</div>

	<canvas class="hidden"
		id="storageCanvas"></canvas>
	<canvas id="previewCanvas"></canvas>

	<div class="flex flex-wrap gap-2 ">
		<button class="border border-black px-2 py-1"
			id="process-button">Process</button>
	</div>


	<script src="wasm_exec.js"></script>
	<script>
		const canvas = document.getElementById('previewCanvas');
		const storageCanvas = document.getElementById('storageCanvas');
		const ctx = canvas.getContext('2d');
		const storageCanvasCtx = storageCanvas.getContext('2d');
		const fileInput = document.getElementById('fileInput');
		const dropZone = document.getElementById('dropZone');
		let imgWidth = 0;
		let imgHeight = 0;

		const sortPixelThreshContainer = document.getElementById("sort-pixel-thresh-container");
		const sortPixelThreshRange = sortPixelThreshContainer.querySelector(`input[type="range"]`);
		const sortPixelThreshDisplay = sortPixelThreshContainer.querySelector(`.display`);
		let sortPixelThresh = parseInt(sortPixelThreshRange.value);
		sortPixelThreshRange.addEventListener("input", (e) => {
			sortPixelThresh = parseInt(e.target.value);
			sortPixelThreshDisplay.innerHTML = sortPixelThresh;
		});

		const colorRangeListContainer = document.getElementById("colorRangeList");
		const defaultColorRanges = {
			"Pale Sweets": [
				[155, 86, 116],
				[203, 179, 255],
				[216, 191, 216],
				[174, 255, 247],
				[199, 251, 150],
			],

			"Pink Candy": [
				[5, 31, 57],
				[74, 36, 128],
				[197, 58, 157],
				[255, 142, 128],
				[255, 255, 255],
			],

			"Sunset Red": [
				[13, 16, 27],
				[40, 26, 45],
				[107, 35, 65],
				[175, 39, 71],
				[238, 36, 61],
			],

			"RGB Pixels": [
				[0, 0, 0],
				[0, 0, 255],
				[0, 255, 0],
				[255, 0, 0],
				[255, 255, 255],

			],
		};

		const makeColorRangeButton = (colors, name) => {
			return `<button data-name="${name}" class="px-2 py-1 border border-black border-purple-500" onclick="setColorRange('${name}')">${name}</button>`;
		};
		let colorRangeHtml = "";
		for (let name in defaultColorRanges) {
			const colors = defaultColorRanges[name];
			colorRangeHtml += makeColorRangeButton(colors, name);
		}
		colorRangeListContainer.innerHTML = colorRangeHtml;


		const setColorRange = (name) => {
			if (!(name in defaultColorRanges))
				return;
			const active = colorRangeListContainer.querySelector("button[data-active]");
			if (active) {
				active.removeAttribute("data-active");
				active.classList.remove("bg-blue-500", "text-white");
			}
			colorRange = defaultColorRanges[name];
			const newActive = colorRangeListContainer.querySelector(`button[data-name="${name}"]`);
			newActive.toggleAttribute("data-active");
			newActive.classList.add("bg-blue-500", "text-white");
		};

		setColorRange("Sunset Red");

		// Handle file selection
		fileInput.addEventListener('change', function (e) {
			handleImage(e.target.files[0]);
		});

		// Prevent default drag behaviors
		['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
			dropZone.addEventListener(eventName, preventDefaults, false);
			document.body.addEventListener(eventName, preventDefaults, false);
		});

		// Highlight drop zone when item is dragged over it
		['dragenter', 'dragover'].forEach(eventName => {
			dropZone.addEventListener(eventName, highlight, false);
		});

		['dragleave', 'drop'].forEach(eventName => {
			dropZone.addEventListener(eventName, unhighlight, false);
		});

		// Handle dropped files
		dropZone.addEventListener('drop', handleDrop, false);

		function preventDefaults(e) {
			e.preventDefault();
			e.stopPropagation();
		}

		function highlight(e) {
			dropZone.classList.add('dragover');
		}

		function unhighlight(e) {
			dropZone.classList.remove('dragover');
		}

		function handleDrop(e) {
			const dt = e.dataTransfer;
			const files = dt.files;
			handleImage(files[0]);
		}

		function handleImage(file) {
			if (!file.type.startsWith('image/')) {
				alert('Please select an image file');
				return;
			}

			const reader = new FileReader();
			reader.onload = function (event) {
				const img = new Image();
				img.onload = function () {
					// Set canvas dimensions to match image (with scaling if needed)
					const maxWidth = 800;
					const maxHeight = 600;

					let width = img.width;
					let height = img.height;

					// Scale image if needed
					if (width > maxWidth || height > maxHeight) {
						const ratio = Math.min(maxWidth / width, maxHeight / height);
						width *= ratio;
						height *= ratio;
					}

					imgWidth = width;
					imgHeight = height;
					canvas.width = width;
					canvas.height = height;
					storageCanvas.width = width;
					storageCanvas.height = height;

					ctx.drawImage(img, 0, 0, width, height);
					storageCanvasCtx.drawImage(img, 0, 0, width, height);
				};
				img.src = event.target.result;
			};
			reader.readAsDataURL(file);
		}

		const processImage = () => {
			const imageData = storageCanvasCtx.getImageData(0, 0, canvas.width, canvas.height);
			const pixels = imageData.data;

			const width = canvas.width;
			const height = canvas.height;

			// const data = goProcessImage(pixels, imgWidth, imgHeight, "dither", new Uint8Array(colorRange.flat()));
			const data = goProcessImage(pixels, imgWidth, imgHeight, "sortPixels", sortPixelThresh);
			const newImageData = new ImageData(data, width, height);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.putImageData(newImageData, 0, 0);
		};
		const processImageButton = document.querySelector("button#process-button");
		processImageButton.addEventListener("click", processImage);

		// Initialize WASM
		const go = new Go();
		WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
			.then((result) => {
				go.run(result.instance);
			})
			.catch((err) => console.error(err));
	</script>
</body>

</html>